<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Orthogonal Trajectories — Family Drawer (numeric substitution)</title>

  <!-- Desmos API loaded with defer -->
  <script src="https://www.desmos.com/api/v1.6/calculator.js" defer></script>

  <style>
    body { margin:0; font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Arial; background:#f7fafc; color:#0f172a; }
    header { padding: 14px; background: linear-gradient(90deg,#0ea5a4,#3b82f6); color:white; font-weight:600; }
    .page { display:flex; gap:20px; padding:18px; }
    .left { width:360px; background:white; padding:16px; border-radius:8px; box-shadow:0 6px 18px rgba(15,23,42,0.06); }
    .right { flex:1; background:white; padding:12px; border-radius:8px; box-shadow:0 6px 18px rgba(15,23,42,0.06); min-height:720px; }
    #calculator, #desmos-fallback { width:100%; height:700px; border-radius:6px; border:1px solid #e6e6e6; background:white; }
    label { display:block; margin:8px 0 4px; font-weight:600; }
    textarea { width:100%; min-height:60px; font-family:monospace; padding:8px; box-sizing:border-box; border-radius:6px; border:1px solid #e6e6e6; }
    input[type=number] { width:100px; padding:6px; border-radius:6px; border:1px solid #e6e6e6; }
    .row { display:flex; gap:8px; align-items:center; margin-bottom:8px; }
    button { padding:8px 12px; background:#3b82f6; color:white; border:none; border-radius:6px; cursor:pointer; margin-right:8px; }
    small.note { color:#64748b; display:block; margin-top:8px; font-size:13px; }
  </style>
</head>
<body>
  <header>Orthogonal Trajectories — Family Drawer (numeric substitution)</header>

  <div class="page">
    <div class="left">
      <label for="equation">Equation (use x and y, Desmos syntax)</label>
      <textarea id="equation">y + \\frac{\\ln(|x|)}{2k} = c</textarea>
      <small class="note">Examples: <code>x^2 + y^2 = k</code>, <code>y = c*sin(x)</code>, <code>y + ln(|x|)/(2k) = c</code></small>

      <label>Parameter sweep (applies to ALL detected parameters)</label>
      <div class="row">
        <div>
          <small>min</small>
          <input id="pmin" type="number" value="-5" step="0.5">
        </div>
        <div>
          <small>max</small>
          <input id="pmax" type="number" value="5" step="0.5">
        </div>
        <div>
          <small>step</small>
          <input id="pstep" type="number" value="1" step="0.1">
        </div>
      </div>

      <div style="margin-top:8px;">
        <button id="draw">Draw Family</button>
        <button id="set-circle">Example: circles</button>
        <button id="set-example">Example: screenshot</button>
      </div>

      <hr/>

      <h4>Notes</h4>
      <small class="note">
        • The page finds identifiers other than <code>x</code> and <code>y</code> and treats them as parameters.<br>
        • For each parameter (e.g. <code>k</code>) the script generates numeric values from <code>pmin</code> to <code>pmax</code> with <code>pstep</code> and substitutes them into the equation, creating separate plotted curves.<br>
        • If no parameter is found, the equation is plotted normally.<br>
        • To avoid overloading Desmos, the total number of plotted curves is capped (200). Adjust ranges/step if you exceed that.
      </small>
    </div>

    <div class="right">
      <div id="calculator" aria-label="Desmos calculator container"></div>
      <iframe id="desmos-fallback" src="about:blank" style="display:none;"></iframe>
    </div>
  </div>

<script>
(function(){
  // find parameter identifiers in a latex string (simple heuristic)
  function findParams(expr) {
    const reserved = new Set([
      'x','y','e','pi','ln','log','sin','cos','tan','sqrt','abs','sec','csc','cot',
      'arcsin','arccos','arctan','exp','floor','ceil','frac','mod','min','max',
      'sin^{-1}','cos^{-1}','tan^{-1}'
    ]);
    // match letter-starting tokens
    const tokens = expr.match(/[a-zA-Z]\\w*/g) || [];
    const params = [];
    for(const t of tokens){
      if(!reserved.has(t) && !params.includes(t)) params.push(t);
    }
    return params;
  }

  function showFallback(){
    document.getElementById('calculator').style.display = 'none';
    const iframe = document.getElementById('desmos-fallback');
    iframe.style.display = 'block';
    iframe.src = 'https://www.desmos.com/calculator';
  }

  function frange(min, max, step){
    const arr = [];
    if(step === 0) return arr;
    if(step > 0){
      for(let v = min; v <= max + 1e-12; v = Math.round((v + step) * 1e12) / 1e12) arr.push(v);
    } else {
      for(let v = min; v >= max - 1e-12; v = Math.round((v + step) * 1e12) / 1e12) arr.push(v);
    }
    return arr;
  }

  // create cartesian product of arrays
  function cartesianProduct(arrays) {
    return arrays.reduce((acc, arr) => {
      const out = [];
      for(const a of acc){
        for(const b of arr){
          out.push(a.concat([b]));
        }
      }
      return out;
    }, [[]]);
  }

  window.addEventListener('load', function(){
    const calcDiv = document.getElementById('calculator');
    if(!calcDiv){ console.error('No calculator element'); showFallback(); return; }

    if(typeof Desmos === 'undefined'){
      setTimeout(function(){
        if(typeof Desmos === 'undefined'){
          console.warn('Desmos script not found; using fallback iframe.');
          showFallback();
        } else {
          initDesmos();
        }
      }, 600);
    } else {
      initDesmos();
    }

    function initDesmos(){
      let calculator;
      try {
        calculator = Desmos.GraphingCalculator(calcDiv, {expressions:true, keypad:false, settingsMenu:true});
      } catch(e){
        console.error('Desmos init error', e);
        showFallback();
        return;
      }

      calculator.setMathBounds({left:-30, right:130, bottom:-50, top:50});

      function drawFamilyFromInput(){
        const raw = document.getElementById('equation').value.trim();
        if(!raw){ alert('Enter an equation'); return; }

        // detect parameters
        const params = findParams(raw).filter(p => p !== 'x' && p !== 'y');

        // parameter sweep settings
        const pmin = parseFloat(document.getElementById('pmin').value) || -5;
        const pmax = parseFloat(document.getElementById('pmax').value) || 5;
        let pstep = parseFloat(document.getElementById('pstep').value);
        if(!isFinite(pstep) || pstep === 0) pstep = 1;

        // Build numeric arrays for each parameter
        const paramValues = {};
        for(const p of params){
          paramValues[p] = frange(pmin, pmax, pstep);
        }

        // Compute total count and cap
        let combos = [[]];
        let paramNames = [];
        if(params.length > 0){
          paramNames = params.slice();
          const arrays = params.map(p => paramValues[p]);
          combos = cartesianProduct(arrays);
        }

        const totalCurves = combos.length;
        const MAX_CURVES = 200;
        if(totalCurves > MAX_CURVES){
          alert('Too many curves (' + totalCurves + '). Increase step or reduce range to draw up to ' + MAX_CURVES + ' curves.');
          return;
        }

        // Build expression list
        const exprs = [];
        // optional: add a base equation for reference (commented out)
        // exprs.push({id:'base', latex:raw, visible:false});

        if(params.length === 0){
          // no parameters -> just add the equation as-is
          exprs.push({ id: 'eq0', latex: raw, color: Desmos.Colors.BLUE });
        } else {
          // for each combination of parameter values, substitute into the latex and add expression
          for(let i=0;i<combos.length;i++){
            const combo = combos[i]; // array of numeric values aligned with paramNames
            let substituted = raw;
            for(let j=0;j<paramNames.length;j++){
              const pname = paramNames[j];
              const pvalue = combo[j];
              // Replace occurrences of pname in the latex with a numeric literal (wrap in parentheses)
              // Use regex with word boundary to avoid partial matches
              const re = new RegExp('\\\\b' + pname + '\\\\b', 'g');
              // But JS RegExp doesn't support \b with non-word characters robustly in LaTeX; instead replace all exact names using a safer method
              substituted = substituted.replace(new RegExp('(?<![\\\\\\w])' + pname + '(?![\\w])','g'), '(' + String(pvalue) + ')');
            }
            // create id and color cycling
            const color = (i % 2 === 0) ? Desmos.Colors.BLUE : Desmos.Colors.PURPLE;
            exprs.push({ id: 'eq_' + i, latex: substituted, color: color });
          }
        }

        // Clear previous expressions and set new ones
        try {
          calculator.setExpressions([]); // clear
          calculator.setExpressions(exprs);
        } catch(e){
          console.error('Error setting expressions:', e);
          alert('Could not set expressions — check the equation syntax.');
        }
      }

      // wires
      document.getElementById('draw').addEventListener('click', drawFamilyFromInput);

      document.getElementById('set-circle').addEventListener('click', function(){
        document.getElementById('equation').value = 'x^2 + y^2 = k';
        document.getElementById('pmin').value = '1';
        document.getElementById('pmax').value = '30';
        document.getElementById('pstep').value = '3';
        drawFamilyFromInput();
      });

      document.getElementById('set-example').addEventListener('click', function(){
        document.getElementById('equation').value = 'y + \\frac{\\ln(|x|)}{2k} = c';
        document.getElementById('pmin').value = '-5';
        document.getElementById('pmax').value = '5';
        document.getElementById('pstep').value = '1';
        drawFamilyFromInput();
      });

      // initial draw
      drawFamilyFromInput();
    } // end initDesmos
  }); // end window load
})();
</script>
</body>
</html>
